# Directional analysis of coaptation line

Citation for package `Directional`.

```{r}
citation("Directional")
```

I need to understand what package `Directional` is doing.
So echo back the R code.

Scatterplot matrix of coaptation line measures.
Link to [SVG](../figures/polarplot.svg) version.

```{r polarplot, dpi = 300}
df %>%
  select(matches("^id|^type$|^(polar|azimuthal)$")) %>%
  melt(id.vars = c("id", "type")) %>% 
  mutate(type = factor(type)) %>% 
  merge(., df %>% select(matches("^id|^type|^radial$"))) %>% 
  ggplot +
    aes(x = value, y = radial, color = type, fill = type) +
    geom_point(alpha = 1/2) +
    scale_color_brewer("", palette = "Set1") +
    scale_fill_brewer("", palette = "Set1") +
    scale_x_continuous("", breaks = seq(-180, 180, 30)) +
    scale_y_log10("Length", breaks = c(5, 10, 20)) +
    facet_wrap(~ variable) +
    coord_polar(start = pi / 2, direction = -1) +
    theme_bw() +
    theme(legend.position = "bottom")
ggsave("../figures/polarplot.svg", dpi = 300)
```

Calculate median cartesian coordinates and latitude and longitude.
**These calculations look incorrect; need to troubleshoot.**

```{r, echo = TRUE}
cartCoord <- df %>% select(matches("^type$|coapUnit[XYZ]"))
matAll <- cartCoord %>% select(-1) %>% as.matrix
matCases <- cartCoord %>% filter(type == "Case") %>% select(-1) %>% as.matrix
matControls <- cartCoord %>% filter(type == "Control") %>% select(-1) %>% as.matrix
merge(rbind(matAll %>% mediandir,
            matCases %>% mediandir,
            matControls %>% mediandir) %>%
        data.frame %>%
        rename(x = X1, y = X2, z = X3) %>%
        cbind(group = c("All", "Cases", "Controls"), .),
      rbind(matAll %>% mediandir %>% euclid.inv,
            matCases %>% mediandir %>% euclid.inv,
            matControls %>% mediandir %>% euclid.inv) %>%
        data.frame %>%
        cbind(group = c("All", "Cases", "Controls"), .)) %>% 
  kable
```

Calculate maximum likelihood estimates of the von Mises-Fisher distribution.
**These calculations look incorrect; need to troubleshoot.**

```{r, echo = TRUE}
merge(rbind(matAll %>% vmf %>% .[["mu"]],
            matCases %>% vmf %>% .[["mu"]],
            matControls %>% vmf %>% .[["mu"]]) %>%
        data.frame %>% 
        rename(x = X1, y = X2, z = X3) %>% 
        cbind(group = c("All", "Cases", "Controls"), .),
      rbind(matAll %>% vmf %>% .[["mu"]] %>% euclid.inv,
            matCases %>% vmf %>% .[["mu"]] %>% euclid.inv,
            matControls %>% vmf %>% .[["mu"]] %>% euclid.inv) %>%
        data.frame %>% 
        cbind(group = c("All", "Cases", "Controls"), .)) %>% 
  kable
```

ANOVA.

```{r, echo = TRUE}
hcf.aov(matAll, factor(df$type))
lr.aov(matAll, factor(df$type))
embed.aov(matAll, factor(df$type))
het.aov(matAll, factor(df$type))
spherconc.test(matAll, factor(df$type))
```

Calculate circular summary statistics.

```{r, echo = TRUE}
cirCoord <- df %>% select(matches("^type$|polar|azimuthal"))
matAll <- cirCoord %>% select(-1) %>% as.matrix
matCases <- cirCoord %>% filter(type == "Case") %>% select(-1) %>% as.matrix
matControls <- cirCoord %>% filter(type == "Control") %>% select(-1) %>% as.matrix
matAll[, "polar"] %>% circ.summary(rads = FALSE, plot = FALSE)
matAll[, "azimuthal"] %>% circ.summary(rads = FALSE, plot = FALSE)
matCases[, "polar"] %>% circ.summary(rads = FALSE, plot = FALSE)
matCases[, "azimuthal"] %>% circ.summary(rads = FALSE, plot = FALSE)
matControls[, "polar"]%>% circ.summary(rads = FALSE, plot = FALSE)
matControls[, "azimuthal"]%>% circ.summary(rads = FALSE, plot = FALSE)
```

Scatterplot matrix of coaptation line measures.
**Not useful; candidate for deletion.** 
 
```{r scatterplotMatrixCoaptationLine, dpi = 300} 
df %>% 
  select(matches("^id|^type$|^(radial|polar|azimuthal)$")) %>% 
  melt(id.vars = c("id", "type")) %>%  
  mutate(type = factor(type)) %>%  
  merge(., ., by = c("id", "type")) %>%  
  filter(variable.x != variable.y) %>%  
  ggplot + 
    aes(x = value.x, y = value.y, color = type) + 
    geom_point(alpha = 1/2) + 
    geom_smooth(method = "lm", se = FALSE) + 
    scale_color_brewer("", palette = "Set1") + 
    scale_x_continuous("") + 
    scale_y_continuous("") + 
    facet_grid(variable.y ~ variable.x, scales = "free") + 
    theme_bw() 
ggsave("../figures/scatterplotMatrixCoaptationLine.svg", dpi = 300) 
``` 
 
Correlations.
Output from `circ.cor1` and `circ.cor2` are quite different.
**Need to reconcile.**

```{r, echo = TRUE}
circ.cor1(df$polar, df$azimuthal, rads = FALSE)
circ.cor2(df$polar, df$azimuthal, rads = FALSE)
circlin.cor(df$polar, df[, c("radial", "bsa", "orifice_area")], rads = FALSE)
circlin.cor(df$azimuthal, df[, c("radial", "bsa", "orifice_area")], rads = FALSE)
```

ANOVA.

```{r, echo = TRUE}
hcf.circaov(matAll[, "polar"], factor(df$type), rads = FALSE)
lr.circaov(matAll[, "polar"], factor(df$type), rads = FALSE)
embed.circaov(matAll[, "polar"], factor(df$type), rads = FALSE)
het.circaov(matAll[, "polar"], factor(df$type), rads = FALSE)
conc.test(matAll[, "polar"], factor(df$type), rads = FALSE)
hcf.circaov(matAll[, "azimuthal"], factor(df$type), rads = FALSE)
lr.circaov(matAll[, "azimuthal"], factor(df$type), rads = FALSE)
embed.circaov(matAll[, "azimuthal"], factor(df$type), rads = FALSE)
het.circaov(matAll[, "azimuthal"], factor(df$type), rads = FALSE)
conc.test(matAll[, "azimuthal"], factor(df$type), rads = FALSE)
```


## Circular regression for polar angle

Unadjusted.

```{r}
new <- df$typeCase %>% unique
M <- spml.reg(df$polar, 
              as.matrix(df[, "typeCase"]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = df$type %>% unique, 
           typeCase = new,
           pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for body surface area.

```{r}
new <- data.frame(typeCase = rep(df$typeCase %>% unique, 3), 
                  bsaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$polar, 
              as.matrix(df[, c("typeCase", "bsaScaled")]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = rep(df$type %>% unique, 3),
           new,
           scaling = rep(c("-1 SD from mean BSA",
                           "Mean BSA",
                           "+1 SD from mean BSA"), each = 2),
           pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for orifice area area.

```{r}
new <- data.frame(typeCase = rep(df$typeCase %>% unique, 3), 
                  orificeAreaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$polar, 
              as.matrix(df[, c("typeCase", "orificeAreaScaled")]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = rep(df$type %>% unique, 3),
           new,
           scaling = rep(c("-1 SD from mean orifice area",
                           "Mean orifice area",
                           "+1 SD from mean orifice area"), each = 2),
           pred = as.vector(M$est) - 360) %>% kable
```


## Circular regression for azimuthal angle

Unadjusted.

```{r}
new <- df$typeCase %>% unique
M <- spml.reg(df$azimuthal, 
              as.matrix(df[, "typeCase"]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = df$type %>% unique, 
           typeCase = new,
           pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for body surface area.

```{r}
new <- data.frame(typeCase = rep(df$typeCase %>% unique, 3), 
                  bsaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$azimuthal, 
              as.matrix(df[, c("typeCase", "bsaScaled")]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = rep(df$type %>% unique, 3),
           new,
           scaling = rep(c("-1 SD from mean BSA",
                           "Mean BSA",
                           "+1 SD from mean BSA"), each = 2),
           pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for orifice area area.

```{r}
new <- data.frame(typeCase = rep(df$typeCase %>% unique, 3), 
                  orificeAreaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$azimuthal, 
              as.matrix(df[, c("typeCase", "orificeAreaScaled")]), 
              rads = FALSE, 
              xnew = as.matrix(new))
M
data.frame(type = rep(df$type %>% unique, 3),
           new,
           scaling = rep(c("-1 SD from mean orifice area",
                           "Mean orifice area",
                           "+1 SD from mean orifice area"), each = 2),
           pred = as.vector(M$est) - 360) %>% kable
```
