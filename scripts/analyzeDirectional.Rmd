# Directional analysis of coaptation line

> From: Benjamin Chan   
> Sent: Wednesday, February 08, 2017 8:15 AM  
> To: G. Michael Silberbach <silberbm@ohsu.edu>  
> Cc: Xiao-Yue Han <hanxi@ohsu.edu>  
> Subject: RE: update  
> 
> Hi Michael,
> 
> Yes, I was thinking along the same path as you. The analysis needs to think of
> the "outcome" as the set of the 3 numbers (or 2 numbers, if you want to think
> of the length separately from the angles) that fully describe the centroid
> line. This brings the statistical analysis into what's called a multivariate
> analysis. It's a little more complicated, but possible. Planning on devoting
> some time on Friday to work it out.
> 
> From: G. Michael Silberbach   
> Sent: Tuesday, February 07, 2017 9:29 PM  
> To: Benjamin Chan <chanb@ohsu.edu>  
> Cc: Xiao-Yue Han <hanxi@ohsu.edu>  
> Subject: RE: update  
> 
> Hi Ben,
> 
> Thinking about the centroid line in space, it may be  incorrect to separate it
> into two numbers and compare cases to controls separately.  We are interested
> in comparing the lines not the angles. The two angles (azimuthal and polar )
> separately may not be different from their control separately but a
> combination of the angles could be different.  Also, what about the
> variability in the centroid length AND angle; is it a big cone or a little
> cone? Let's talk about this some more.
> 
> Assuming that we don't need to analyze the centroid angle and length more,
> these data suggest that the sinus mirror hypothesis predicts a normal aortic
> valve in terms of coaptation area and "shape".
> 
> Michael

Scatterplot matrix of coaptation line measures.

```{r scatterplotMatrixCoaptationLine, dpi = 300}
df %>%
  select(matches("^id|^type|^(radial|polar|azimuthal)$")) %>%
  melt(id.vars = c("id", "type")) %>% 
  mutate(type = factor(type)) %>% 
  merge(., ., by = c("id", "type")) %>% 
  filter(variable.x != variable.y) %>% 
  ggplot +
    aes(x = value.x, y = value.y, color = type) +
    geom_point(alpha = 1/2) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_color_brewer("", palette = "Set1") +
    scale_x_continuous("") +
    scale_y_continuous("") +
    facet_grid(variable.y ~ variable.x, scales = "free") +
    theme_bw()
ggsave("../figures/scatterplotMatrixCoaptationLine.svg", dpi = 300)
```

```{r polarplot, dpi = 300}
df %>%
  select(matches("^id|^type|^(polar|azimuthal)$")) %>%
  melt(id.vars = c("id", "type")) %>% 
  mutate(type = factor(type)) %>% 
  merge(., df %>% select(matches("^id|^type|^radial$"))) %>% 
  ggplot +
    aes(x = value, y = radial, color = type, fill = type) +
    geom_point(alpha = 1/2) +
    scale_color_brewer("", palette = "Set1") +
    scale_fill_brewer("", palette = "Set1") +
    scale_x_continuous("", breaks = seq(-180, 180, 30)) +
    scale_y_log10("Length", breaks = c(5, 10, 20)) +
    facet_grid(variable ~ type) +
    coord_polar(start = pi / 2, direction = -1) +
    theme_bw() +
    theme(legend.position = "none")
ggsave("../figures/polarplot.svg", dpi = 300)
```

Calculate median cartesian coordinates.

```{r, echo = TRUE}
df %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% mediandir
df %>% filter(type == "Case") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% mediandir
df %>% filter(type == "Control") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% mediandir
```

Calculate maximum likelihood estimates of the von Mises-Fisher distribution.

```{r, echo = TRUE}
df %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf
df %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf %>% .[["mu"]] %>% euclid.inv
df %>% filter(type == "Case") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf
df %>% filter(type == "Case") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf %>% .[["mu"]] %>% euclid.inv
df %>% filter(type == "Control") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf
df %>% filter(type == "Control") %>% select(matches("coapUnit[XYZ]")) %>% as.matrix %>% vmf %>% .[["mu"]] %>% euclid.inv
```

Calculate circular summary statistics.

```{r, echo = TRUE}
df %>% select(matches("polar")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
df %>% select(matches("azimuthal")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
df %>% filter(type == "Case") %>% select(matches("polar")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
df %>% filter(type == "Case") %>% select(matches("azimuthal")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
df %>% filter(type == "Control") %>% select(matches("polar")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
df %>% filter(type == "Control") %>% select(matches("azimuthal")) %>% as.matrix %>% circ.summary(rads = FALSE, plot = FALSE)
```

Correlations.

```{r, echo = TRUE}
circ.cor1(df$polar, df$azimuthal, rads = FALSE)
circ.cor2(df$polar, df$azimuthal, rads = FALSE)
circlin.cor(df$polar, df[, c("radial", "bsa", "orifice_area")], rads = FALSE)
circlin.cor(df$azimuthal, df[, c("radial", "bsa", "orifice_area")], rads = FALSE)
```

ANOVA.

```{r, echo = TRUE}
x <- df %>% select(matches("coapUnit[XYZ]")) %>% as.matrix
ina <- df$type
hcf.aov(x, ina)
lr.aov(x, ina)
embed.aov(x, ina)
het.aov(x, ina)
spherconc.test(x, ina)
```

ANOVA.

```{r, echo = TRUE}
x <- df %>% select(matches("polar|azimuthal")) %>% as.matrix
ina <- df$type
hcf.circaov(x, ina, rads = FALSE)
lr.circaov(x, ina, rads = FALSE)
embed.circaov(x, ina, rads = FALSE)
het.circaov(x, ina, rads = FALSE)
conc.test(x, ina, rads = FALSE)
```


## Circular regression for polar angle

Unadjusted.

```{r}
new <- data.frame(type = df$type %>% levels)
M <- spml.reg(df$polar, df$type, rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for body surface area.

```{r}
new <- data.frame(type = rep(df$type %>% levels, 3), bsaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$polar, df[, c("type", "bsaScaled")], rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for orifice area area.

```{r}
new <- data.frame(type = rep(df$type %>% levels, 3), orificeAreaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$polar, df[, c("type", "orificeAreaScaled")], rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```


## Circular regression for azimuthal angle

Unadjusted.

```{r}
new <- data.frame(type = df$type %>% levels)
M <- spml.reg(df$azimuthal, df$type, rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for body surface area.

```{r}
new <- data.frame(type = rep(df$type %>% levels, 3), bsaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$azimuthal, df[, c("type", "bsaScaled")], rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```

Adjusted for orifice area area.

```{r}
new <- data.frame(type = rep(df$type %>% levels, 3), orificeAreaScaled = rep(-1:1, each = 2))
M <- spml.reg(df$azimuthal, df[, c("type", "orificeAreaScaled")], rads = FALSE, xnew = new)
M
data.frame(new, pred = as.vector(M$est) - 360) %>% kable
```
